//! Output File Loader
//! 
//! Utilities for loading and analyzing output files generated by the orchestrator

use std::fs;
use std::path::Path;
use serde::{Deserialize, Serialize};
use crate::runtime::TracingCollector;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OutputMetadata {
    pub created_at: String,
    pub topic: String,
    pub total_attributes: usize,
    pub updated_at: String,
    pub version: String,
}

#[derive(Debug, Clone)]
pub struct OutputData {
    pub attributes: Vec<String>,
    pub metadata: Option<OutputMetadata>,
    pub file_path: String,
}

pub struct OutputLoader;

impl OutputLoader {
    /// Load output.txt file from the given path
    pub fn load_output_file<P: AsRef<Path>>(path: P) -> Result<OutputData, Box<dyn std::error::Error>> {
        let file_path = path.as_ref().to_string_lossy().to_string();
        
        if !path.as_ref().exists() {
            return Err(format!("Output file does not exist: {}", file_path).into());
        }
        
        let content = fs::read_to_string(&path)?;
        let attributes: Vec<String> = content
            .lines()
            .map(|line| line.trim().to_string())
            .filter(|line| !line.is_empty())
            .collect();
        
        tracing::info!("üìÑ Loaded {} attributes from {}", attributes.len(), file_path);
        
        Ok(OutputData {
            attributes,
            metadata: None,
            file_path,
        })
    }
    
    /// Load output.txt and metadata.json from a directory
    pub fn load_output_dir<P: AsRef<Path>>(dir_path: P) -> Result<OutputData, Box<dyn std::error::Error>> {
        let output_file = dir_path.as_ref().join("output.txt");
        let metadata_file = dir_path.as_ref().join("metadata.json");
        
        let mut output_data = Self::load_output_file(&output_file)?;
        
        // Try to load metadata if it exists
        if metadata_file.exists() {
            match Self::load_metadata(&metadata_file) {
                Ok(metadata) => {
                    output_data.metadata = Some(metadata);
                    tracing::info!("üìä Loaded metadata from {}", metadata_file.display());
                }
                Err(e) => {
                    tracing::warn!("‚ö†Ô∏è Failed to load metadata: {}", e);
                }
            }
        }
        
        Ok(output_data)
    }
    
    /// Load metadata.json file
    pub fn load_metadata<P: AsRef<Path>>(path: P) -> Result<OutputMetadata, Box<dyn std::error::Error>> {
        let content = fs::read_to_string(&path)?;
        let metadata: OutputMetadata = serde_json::from_str(&content)?;
        Ok(metadata)
    }
    
    /// Load output from orchestrator config (automatically determines path)
    pub fn load_from_config(config: &crate::config::OrchestratorConfig) -> Result<OutputData, Box<dyn std::error::Error>> {
        let output_dir = config.get_output_dir();
        Self::load_output_dir(&output_dir)
    }
    
    /// Load output by extracting topic from traces
    /// Automatically determines the output directory based on the topic found in traces
    pub fn load_from_traces(collector: &TracingCollector) -> Result<OutputData, Box<dyn std::error::Error>> {
        let topic = collector.extract_topic()
            .ok_or("Could not extract topic from traces")?;
        
        let output_dir = format!("./output/{}", topic);
        tracing::info!("üìÇ Loading output from extracted topic '{}' -> {}", topic, output_dir);
        
        Self::load_output_dir(&output_dir)
    }
    
    /// Load output by topic name (when you know the topic)
    pub fn load_from_topic(topic: &str) -> Result<OutputData, Box<dyn std::error::Error>> {
        let output_dir = format!("./output/{}", topic);
        tracing::info!("üìÇ Loading output for topic '{}' -> {}", topic, output_dir);
        
        Self::load_output_dir(&output_dir)
    }
    
    /// Load output with custom base directory and extracted topic
    pub fn load_from_traces_with_base_dir(collector: &TracingCollector, base_dir: &str) -> Result<OutputData, Box<dyn std::error::Error>> {
        let topic = collector.extract_topic()
            .ok_or("Could not extract topic from traces")?;
        
        let output_dir = format!("{}/{}", base_dir, topic);
        tracing::info!("üìÇ Loading output from extracted topic '{}' -> {}", topic, output_dir);
        
        Self::load_output_dir(&output_dir)
    }
}

impl OutputData {
    /// Get the number of unique attributes
    pub fn attribute_count(&self) -> usize {
        self.attributes.len()
    }
    
    /// Check if a specific attribute exists
    pub fn contains_attribute(&self, attribute: &str) -> bool {
        self.attributes.iter().any(|attr| attr == attribute)
    }
    
    /// Get attributes containing a specific substring
    pub fn find_attributes_containing(&self, substring: &str) -> Vec<&String> {
        self.attributes
            .iter()
            .filter(|attr| attr.contains(substring))
            .collect()
    }
    
    /// Get the first N attributes
    pub fn first_n_attributes(&self, n: usize) -> &[String] {
        &self.attributes[..n.min(self.attributes.len())]
    }
    
    /// Get the last N attributes
    pub fn last_n_attributes(&self, n: usize) -> &[String] {
        let start = self.attributes.len().saturating_sub(n);
        &self.attributes[start..]
    }
    
    /// Compare with another OutputData to find differences
    pub fn compare_with(&self, other: &OutputData) -> OutputComparison {
        let mut only_in_self = Vec::new();
        let mut only_in_other = Vec::new();
        let mut common = Vec::new();
        
        for attr in &self.attributes {
            if other.contains_attribute(attr) {
                common.push(attr.clone());
            } else {
                only_in_self.push(attr.clone());
            }
        }
        
        for attr in &other.attributes {
            if !self.contains_attribute(attr) {
                only_in_other.push(attr.clone());
            }
        }
        
        OutputComparison {
            common,
            only_in_first: only_in_self,
            only_in_second: only_in_other,
        }
    }
}

#[derive(Debug, Clone)]
pub struct OutputComparison {
    pub common: Vec<String>,
    pub only_in_first: Vec<String>,
    pub only_in_second: Vec<String>,
}

impl OutputComparison {
    pub fn similarity_ratio(&self) -> f64 {
        let total = self.common.len() + self.only_in_first.len() + self.only_in_second.len();
        if total == 0 {
            1.0
        } else {
            self.common.len() as f64 / total as f64
        }
    }
    
    pub fn is_identical(&self) -> bool {
        self.only_in_first.is_empty() && self.only_in_second.is_empty()
    }
}